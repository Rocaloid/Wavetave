#{
    Title: Plugin_HarmonicMarking_Naive
    
    The simplified version of Plugin_HarmonicMarking, which doesn't do
    fundamental frequency correction as marking harmonic peaks. Instead it uses
    F0 generated by Plugin_F0Marking_ByPhase to achieve a much higher accuracy.
    
    Function: Plugin_HarmonicMarking_Naive
    
    Parameters:
    
        Spectrum - The decibel-magnitude spectrum to be analyzed.
        (1 Dimensional Real Array)

    Input Global Variables:
        
        <FFTSize>
        
        <SampleRate>
        
        <SpectrumUpperRange>
    
        <Plugin_Var_F0_Exact>

    Output Global Variables:
    
        <Plugin_Var_Harmonics_Freq>
    
        <Plugin_Var_Harmonics_Magn>
    
    Dependency:
    
        Plugin_F0Marking_ByPhase
#}
function Plugin_HarmonicMarking_Naive(Spectrum)
        global FFTSize;
        global SampleRate;
        global Plugin_Var_F0_Exact;
        global SpectrumUpperRange;
        global Environment;
        #{
            Section: Globals
            
            Variable: Plugin_Var_Harmonics_Freq
                
                An array of frequencies(bin-index) of harmonic peaks.
                
                (1 Dimensional Int Array)
        #}
        global Plugin_Var_Harmonics_Freq;
        
        #{
            Variable: Plugin_Var_Harmonics_Magn
                
                An array of magnitudes(dB) of harmonic peaks.
                
                (1 Dimensional Real Array)
        #}
        global Plugin_Var_Harmonics_Magn;

        #Clear
        Plugin_Var_Harmonics_Freq = 0;
        Plugin_Var_Harmonics_Magn = 0;
        
        #If the data is valid
        if(Plugin_Var_F0_Exact > 50)
        
                #F0
                PinX = Plugin_Var_F0_Exact * FFTSize / SampleRate;
                [PinY, X] = max(Spectrum(fix(PinX) - 3 : fix(PinX) + 3));
                X += fix(PinX) - 4;
                Plugin_Var_Harmonics_Freq(1) = X;
                Plugin_Var_Harmonics_Magn(1) = PinY;
        
                for i = 2 : fix(SpectrumUpperRange / Plugin_Var_F0_Exact)
                        #Finding maximum
                        PinX = Plugin_Var_F0_Exact * FFTSize / SampleRate * i;
                        [PinY, X] = max(Spectrum(fix(PinX) - 3 : fix(PinX) + 3));
                        X += fix(PinX) - 4;
                        
                        Plugin_Var_Harmonics_Freq(i) = X;
                        Plugin_Var_Harmonics_Magn(i) = PinY;
                        
                        #Plotting
                        if(strcmp(Environment, "Visual"))
                                text(PinX, PinY + 5, strcat("H", mat2str(i - 1)));
                                text(PinX, PinY, cstrcat("x ",
                                     mat2str(fix(PinX * SampleRate / FFTSize)), "Hz"));
                        end
                end
        endif
end

